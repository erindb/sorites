// ARGS.give_a_number data frame
// ARGS.concrete data frame
// ARGS.objects vector of objects

var objects = levels(ARGS.sorites, "object");

var give_a_number_model = function() {
  var MUMAX = 10;
  var SIGMAX = 3;

  foreach(objects, function(obj) {

    // subset each data type
    // var prior_bins = _.filter(ARGS.priorbins, {item: obj});
    var give_a_number = _.filter(ARGS.give_a_number, {object: obj});

    // var concrete = _.filter(ARGS.sorites, {object: obj, qtype: "concrete"});
    // var inductive = _.filter(ARGS.sorites, {object: obj, qtype: "inductive"});

    // priors on parameters of RSA state priors
    var item_params = {
      mu: uniformDrift({a: 0, b: MUMAX, width: 1}),
      sigma: uniformDrift({a: 0, b: SIGMAX, width: 0.5})
    };

    // factor by likelihood of sampled responses from give-a-number task
    mapData({data: give_a_number}, function(d) {
      // assume log of price is normally distributed
      // so use lognormal density function
      // (see "mistakes_i_made.html" if in the future this doesn't make sense)
      factor(lognormal_score(d.price, item_params));
    });

    add_output_datapoint(
      {type: "prior", object: obj, label: "mu"},
      item_params.mu
    );
    add_output_datapoint(
      {type: "prior", object: obj, label: "sigma"},
      item_params.sigma
    );

  });

  return query;
};

"finished";
