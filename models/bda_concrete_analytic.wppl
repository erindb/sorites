// ARGS.give_a_number data frame
// ARGS.concrete data frame
// ARGS.objects vector of objects

var objects = levels(ARGS.sorites, "object");

var s1_score = function(utterance, theta, item_params, alpha1) {
  return 0;
};

var concrete_premise_model = function() {

  var ALPHA1MAX = 20;
  var ALPHA2MAX = 5;
  var COSTMAX = 10;
  var MUMAX = 10;
  var SIGMAX = 3;
  var SIGBINMAX = 0.5;

  var global_params = {
    alpha1: uniformDrift({a: 0, b: ALPHA1MAX, width: 1}),
    alpha2: uniformDrift({a: 0, b: ALPHA2MAX, width: 0.5}),
    cost: uniformDrift({a: 0, b: COSTMAX, width: 0.5}),
    sigbin: uniformDrift({a: 0, b: SIGBINMAX, width: 0.5})
  };

  // utterance prior
  var adjectivePriorProb = Math.exp(-global_params.cost);
  var utterancePrior = Categorical({
    vs: ["expensive", "silence"],
    ps: [adjectivePriorProb, 1]
  });

  mapData({data: objects}, function(obj_name) {

    // subset to get each data type
    var give_a_number = _.filter(ARGS.give_a_number, {object: obj_name});
    var concrete = _.filter(ARGS.sorites, {object: obj_name, qtype: "concrete"});

    // priors on parameters of RSA state priors
    var item_params = {
      mu: uniformDrift({a: 0, b: MUMAX, width: 1}),
      sigma: uniformDrift({a: 0, b: SIGMAX, width: 0.5})
    };

    var dollar_amounts = levels(concrete, "dollar_amount");
    var max_price = utils.max(dollar_amounts);

    // factor by likelihood of sampled responses from give-a-number task
    mapData({data: give_a_number}, function(d) {
      // assume log of price is normally distributed
      // so use lognormal density function
      // (see "mistakes_i_made.html" if in the future this doesn't make sense)
      factor(lognormal_score(d.price, item_params));
    });

    // log of probability that speaker will say this utterance, given this price and theta
    var speaker1_score = function(utterance, price, theta) {
      if (theta < price) {
        // If "expensive" is actually true, then the speaker can say it.
        // This is where it gets complicated.

        // Probability mass where expensive is true
        var prob_mass_above_theta = 1 - utils.lognormalCDF(theta, item_params);
        // Speaker normalization constant: sum of informativities of the two possible utterances.
        // var p_expensive = 0.5;
        // var p_silence = 0.5;
        var p_expensive = Math.exp(utterancePrior.score("expensive"));
        var p_silence = Math.exp(utterancePrior.score("silence"));
        // Unnormalized probabilities:
        var unnormalized_expensive = p_expensive / Math.pow(prob_mass_above_theta, global_params.alpha1);
        var unnormalized_silence = p_silence;
        var Z = unnormalized_expensive + unnormalized_silence;
        if (utterance == "expensive") {
          return Math.log(unnormalized_expensive / Z);
        } else {
          return Math.log(unnormalized_silence / Z);
        }
      } else {
        if (utterance == "expensive") {
          // If expensive is just false, the probability of saying it's expensive is 0.
          // So the factor is -Infinity.
          return -Infinity;
        } else {
          return 0;
        }
      }
      return 0;
    };

    var listener1 = cache(function(utterance) {
      var iterations = ARGS.internal_iterations[0];
      return kde(Infer(
        {method: "rejection", incremental: true, samples: iterations},
        // {method: "incrementalMH", samples: iterations, burn: iterations/2},
        // {method: "MCMC", samples: iterations, burn: iterations/2, lag: 1},
        function() {
          var logprice = gaussian(item_params);
          var price = Math.exp(logprice);
          var theta = uniform(0, max_price);
          var likelihood = speaker1_score(utterance, price, theta);
          factor(likelihood);
          return price;
        }
      ));
    });

    var speaker2 = cache(function(dollar_amount) {
      return Infer({method: "enumerate"}, function() {
        var utterance = sample(utterancePrior);
        var L1 = listener1(utterance);
        var informativity = L1.score(dollar_amount);
        factor(global_params.alpha2 * informativity);
        return utterance;
      })
    });

     // output for each condition in sorites experiment
    mapData({data: dollar_amounts}, function(dollar_amount){
      var concrete_byDollar = _.filter(concrete, {dollar_amount: dollar_amount});

      // ERP from utterances to probabilities, given the price of an object,
      // marginalizing over theta
      var S2 = speaker2(dollar_amount);

      mapData({data: concrete_byDollar}, function(d){
        // for now, assume if > 5, then "YES", other NO
        var binarizedResponse = (d.response > 5) ? "expensive" : "silence";
        observe(S2, binarizedResponse);
      });

      // if "expensive isn't in the support, return probability 0"
      var concrete_prob =  ( (_.includes(S2.support(), "expensive")) ?
                             Math.exp(S2.score("expensive")) :
                             0 );
      add_output_datapoint(
        {type: "concrete", "object": obj_name, dollar_amount: JSON.stringify(dollar_amount)},
        concrete_prob
      );
    });

    add_output_datapoint(
      {type: "prior", object: obj_name, label: "mu"},
      item_params.mu
    );
    add_output_datapoint(
      {type: "prior", object: obj_name, label: "sigma"},
      item_params.sigma
    );

  });

  add_output_datapoint(
    {type: "param", label: "alpha1"},
    global_params.alpha1
  );

  add_output_datapoint(
    {type: "param", label: "alpha2"},
    global_params.alpha2
  );

  add_output_datapoint(
    {type: "param", label: "cost"},
    global_params.cost
  );

  return query;
};


"finished";
