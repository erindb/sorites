// ARGS.give_a_number data frame
// ARGS.concrete data frame
// ARGS.objects vector of objects

var objects = levels(ARGS.sorites, "object");

var meaning = function(utterance, x, theta) {
  if (utterance == "expensive") {
    if (theta < x) {
      // if x's range is above theta's range, then x is above theta
      // so it's expensive
      return true;
    } else if (theta == x) {
      // if they're in the same range, it's expensive iff the dir
      // says that x is above theta
      return flip();
    } else {
      // if x's range isn't above or at theta's range, then it's not expensive
      return false;
    }
  } else {
    // return true for silence
    return true;
  }
};

var enumerate_wrapper = function(erp) {
  if (utils.max(map(function(x) {return x.factor;}, erp.support())) == -Infinity) {
    return "impossible";
  } else {
    return Infer({method: "enumerate", model: function() {
      var x = sample(erp);
      factor(x.factor);
      return x.value;
    }});
  }
};

var get_dollar_amounts = cache(function(obj) {
  var concrete = _.filter(ARGS.sorites, {object: obj, qtype: "concrete"});
  var dollar_amounts = levels(concrete, "dollar_amount");
  return dollar_amounts;
});

var get_bins = cache(function(obj) {
  var dollar_amounts = get_dollar_amounts(obj);
  var bins = utils.get_bins(dollar_amounts);
  return bins;
});

var concrete_premise_model = function() {

  var ALPHA1MAX = 1;
  var ALPHA2MAX = 1;
  var COSTMAX = 5;
  var MUMAX = 10;
  var SIGMAX = 3;
  var SIGBINMAX = 0.5;

  var global_params = {
    alpha1: uniformDrift({a: 0, b: ALPHA1MAX, width: 1}),
    alpha2: uniformDrift({a: 0, b: ALPHA2MAX, width: 0.5}),
    cost: uniformDrift({a: 0, b: COSTMAX, width: 0.5}),
    sigbin: uniformDrift({a: 0, b: SIGBINMAX, width: 0.5})
  };

  // Utterance prior
  var adjectivePriorProb = Math.exp(-global_params.cost);
  var utterancePrior = Categorical({
    vs: ["expensive", "silence"],
    ps: [adjectivePriorProb, 1]
  });

  foreach(objects, function(obj) {

    // Subset to get each data type
    var give_a_number = _.filter(ARGS.give_a_number, {object: obj});
    var concrete = _.filter(ARGS.sorites, {object: obj, qtype: "concrete"});
    var dollar_amounts = levels(concrete, "dollar_amount");

    // priors on parameters of RSA state priors
    var item_params = {
      mu: uniformDrift({a: 0, b: MUMAX, width: 1}),
      sigma: uniformDrift({a: 0, b: SIGMAX, width: 0.5})
    };

    // Discretization
    var dollar_amounts = get_dollar_amounts(obj);
    var bins = get_bins(obj);
    var thetaPrior = DiscretizedUniform(bins);
    var statePrior = DiscretizedLognormal(item_params, bins);

    // factor by likelihood of sampled responses from give-a-number task
    mapData({data: give_a_number}, function(d) {
      // assume log of price is normally distributed
      // so use lognormal density function
      // (see "mistakes_i_made.html" if in the future this doesn't make sense)
      factor(lognormal_score(d.price, item_params));
    });

    var listener0 = cache(function(utterance, theta) {
      // If speaker1 says "expensive" to try to convey a value of x
      // that's less than the speaker's theta, then all factors will
      // be -Infinity.
      return enumerate_wrapper(Infer({method: "enumerate"}, function() {
        var x = sample(statePrior);
        var f = meaning(utterance, x, theta) ? 0 : -Infinity;
        return {value: x, factor: f};
      }));
    });

    var speaker1 = cache(function(x, theta) {
      // If the speaker says nothing, then we could infer any x,
      // So at least one of the paths should have score above -Infinity
      return Infer({method: "enumerate"}, function() {
        var utterance = sample(utterancePrior);
        var L0 = listener0(utterance, theta);
        if (L0 == "impossible") {
          factor(-Infinity);
          return utterance;
        } else {
          var informativity = (
            _.includes(L0.support(), x) ?
            L0.score(x) :
            -Infinity
          );
          var f = global_params.alpha1 * informativity;
          factor(f);
          return utterance;
        }
      });
    });

    var listener1 = cache(function(utterance) {
      return Infer({method: "enumerate"}, function() {
        var theta = sample(thetaPrior);
        var x = sample(statePrior);
        var S1 = speaker1(x, theta);
        // If there's an x-theta pair that's incompatible with the
        // utterance, then it will have score -Infinity.
        var likelihood = (
          _.includes(S1.support(), utterance) ?
          S1.score(utterance) :
          -Infinity
        );
        factor(likelihood);
        return x;
      });
    });

    var speaker2 = cache(function(dollar_amount) {
      return Infer({method: "enumerate"}, function() {
        var utterance = sample(utterancePrior);
        var L1 = listener1(utterance);
        var x = utils.find_bin(dollar_amount, bins);
        // if (obj == "laptop") {
        //   display(dollar_amount);
        //   display(xbin);
        // }
        var informativity = ( _.includes(L1.support(), x) ? L1.score(x) : 0 );
        factor(global_params.alpha2 * informativity);
        return utterance; 
      })
    });

     // output for each condition in sorites experiment
    foreach(dollar_amounts, function(dollar_amount){
      var concrete_byDollar = _.filter(concrete, {dollar_amount: dollar_amount});
      
      // // Test L0
      // var L0 = listener0("expensive", bins[0].a);
      // // display(L0);

      // // Test S1
      // var S1 = speaker1(1, 0);
      // // display(S1);

      // // Test L1
      // listener1("expensive");
      // // display(listener1("expensive"));
      // // display(listener1("silence"));

      // // Test S2
      // // display(dollar_amount);
      // var S2 = speaker2(dollar_amount);

      // ERP from utterances to probabilities, given the price of an object,
      // marginalizing over theta
      var S2 = speaker2(dollar_amount);

      mapData({data: concrete_byDollar}, function(d){
        // for now, assume if > 5, then "YES", other NO
        var binarizedResponse = (d.response > 5) ? "expensive" : "silence";
        observe(S2, binarizedResponse);
      });

      // if "expensive isn't in the support, return probability 0"
      var concrete_prob =  ( (_.includes(S2.support(), "expensive")) ?
                             Math.exp(S2.score("expensive")) :
                             0 );
      add_output_datapoint(
        {type: "concrete", label: "endorsement", object: obj, dollar_amount: JSON.stringify(dollar_amount)},
        concrete_prob
      );

    });

    add_output_datapoint(
      {type: "prior", object: obj, label: "mu"},
      item_params.mu
    );
    add_output_datapoint(
      {type: "prior", object: obj, label: "sigma"},
      item_params.sigma
    );

  });

  return query;

};


"finished";
