var fs = require('fs');
// var csvtojson = require('csvtojson');
var babyparse = require('babyparse');
var jStat = require('jStat').jStat;

function readCSV(filename) {
  return babyparse.parse(fs.readFileSync(filename, 'utf8'));
}

function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function closest(arr, closestTo){

    var closest = Math.max.apply(null, arr); //Get the highest number in arr in case it match nothing.
    for(var i = 0; i < arr.length; i++){ //Loop the array
        if(arr[i] >= closestTo && arr[i] < closest) closest = arr[i]; //Check if it's higher than your number, but lower than your closest value
    }
    return closest; // return the value
}

function numeric(a,b) {
  return a-b;
}

function median(a,b) {
  return (b-a)/2 + a;
}

function bins(dollar_amounts) {
  // Sort dollar amounts so bins are sequential.
  dollar_amounts.sort(numeric);
  // Give threshold a generous maximum value.
  var max_theta = 1.5*dollar_amounts[dollar_amounts.length-2];

  // Initialize all bin values;
  var lowerBins = [];
  var upperBins = [];
  var midBins = [];
  var thetaBins = [];
  var thetaProbs = [];

  // Iterate through dollar amounts to construct bins.
  var cutoff_below = 0;
  var cutoff_above = null;
  var current_dollar_amount = null;
  var next_dollar_amount = null;
  var previous_midpoint = 0;
  var current_midpoint = null;
  var theta = null;
  var theta_prob = null;
  for (var i = 0; i < dollar_amounts.length; i++) {
    // Each bin should contain the current dollar amount.
    current_dollar_amount = dollar_amounts[i];
    // Its upper value should be between this dollar amount and the next one.
    // Bins might be different widths.
    if (i == (dollar_amounts.length-1)) {
      cutoff_above = Infinity
    } else {
      next_dollar_amount = dollar_amounts[i+1];
    }
    cutoff_above = median(current_dollar_amount, next_dollar_amount);
    // The midpoint of the bin is between the upper and lower cutoffs.
    // (This is not necessarily the current dollar amount.)
    current_midpoint = median(cutoff_below, cutoff_above);
    // Let the highest bin's midpoint be at the max value of theta.
    if (current_midpoint==Infinity) {
      current_midpoint = max_theta;
    }
    // Thetas should be between bins.
    theta = cutoff_below;
    // The probability of a theta being sampled that's between a given pair of
    // bins is proportional to the length of the interval between the midpoints.
    theta_prob = (current_midpoint - previous_midpoint)/max_theta;

    lowerBins.push(cutoff_below);
    upperBins.push(cutoff_above);
    midBins.push(current_midpoint);
    thetaBins.push(theta);
    thetaProbs.push(theta_prob);

    cutoff_below = cutoff_above;
    previous_midpoint = current_midpoint;
  }

  return {
    "mid": midBins,
    "lower": lowerBins,
    "upper": upperBins,
    "theta": thetaBins,
    "theta_prob": thetaProbs
  }
}


// can work with an erp of query.tables (useful for data analysis models)
var writeQueryERP = function(erp, filename, header) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,header + ',prob\n')
 supp.forEach(function(s) {
   supportWriter(s, Math.exp(erp.score(s)), csvFile);
 })
 fs.closeSync(csvFile);
};

var naturalpriorERPWriter = function(erp, filename) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,'Property,Parameter,Value,Probability\n')
 supp.forEach(function(s) {supportWriter(s, Math.exp(erp.score(s)), csvFile);})
 fs.closeSync(csvFile);
}

var naturalcasepriorERPWriter = function(erp, filename) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,'Property,Category,Parameter,Value,Probability\n')
 supp.forEach(function(s) {supportWriter(s, Math.exp(erp.score(s)), csvFile);})
 fs.closeSync(csvFile);
}

var writeLstOfObjectSupport = function(erp, filename, header) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,header + ',prob\n')
 supp.forEach(function(s) {lstObjectSupportWriter(s, Math.exp(erp.score(s)), csvFile);})
 fs.closeSync(csvFile);
};

var lstObjectSupportWriter = function(s, p, handle) {
 // var sLst = _.toPairs(s);
 var l = s.length;
 for (var i = 0; i < l; i++) {
   fs.writeSync(handle, _.values(s[i]).join(',')+','+p+'\n');
 }
};


var supportWriter = function(s, p, handle) {
 var sLst = _.toPairs(s);
 var l = sLst.length;
 for (var i = 0; i < l; i++) {
   // console.log(sLst[i].join(','))
   fs.writeSync(handle, sLst[i].join(',')+','+p+'\n');
 }
};

function fillArray(value, len) {
  var arr = [];
  for (var i = 0; i < len; i++) {
    arr.push(value);
  }
  return arr;
};

function wpParseFloat(x){
  return parseFloat(x);
};

function betaCDF(x, params){
  return jStat.beta.cdf( x, params.a, params.b )
}

function uniformCDF(x, params){
  return jStat.uniform.cdf( x, params.a, params.b )
}

function gaussianCDF(x, params){
  return jStat.normal.cdf( x, params.mu, params.sigma )
}
function lognormalCDF(x, params){
  return jStat.lognormal.cdf( x, params.mu, params.sigma )
}

var LOG_2PI = 1.83787706641;
function lognormalScore(x, params) {
  var mu = params.mu;
  var sigma = params.sigma;
  var logx = Math.log(x);
  return (
    -logx
    - Math.log(sigma)
    - 0.5 * (
      LOG_2PI + (logx - mu) * (logx - mu) / (sigma * sigma)
    )
  )
};

function readCSV(filename){
  return babyparse.parse(fs.readFileSync(filename, 'utf8'));
};

function writeCSV(jsonCSV, filename){
  fs.writeFileSync(filename, babyparse.unparse(jsonCSV) + "\n");
}

function writeJSON(x, filename) {
  fs.writeFileSync(filename, JSON.stringify(x, undefined, indent=2) + "\n");
}


var openFile = function(filename) {
 var csvFile = fs.openSync(filename, 'w');
 return csvFile
};

var closeFile = function(handle){
 fs.closeSync(handle);
};


var writeLine = function(handle, line){
  fs.writeSync(handle, line+'\n');
};

var saveERP = function(erp, extraColumns, handle) {
   // var handle = openFile(file);
   var supp = erp.support();
   supp.forEach(function(s) {writeLine(handle, extraColumns.concat([s, Math.exp(erp.score(s))]));})
   // closeFile(handle)
};

var float = function(x) {
  return parseFloat(x);
};

module.exports = {
  saveERP: saveERP,
  openFile: openFile,
  closeFile: closeFile,
  writeLine: writeLine,
  writeCSV: writeCSV,
  writeJSON: writeJSON,
  readCSV: readCSV,
  isNumber: isNumber,
  fillArray: fillArray,
  writeQueryERP: writeQueryERP,
  naturalpriorERPWriter: naturalpriorERPWriter,
  naturalcasepriorERPWriter: naturalcasepriorERPWriter,
  closest: closest,
  wpParseFloat: wpParseFloat,
  bins: bins,
  betaCDF: betaCDF,
  uniformCDF: uniformCDF,
  gaussianCDF: gaussianCDF,
  lognormalCDF: lognormalCDF,
  lognormalScore: lognormalScore,
  writeLstOfObjectSupport: writeLstOfObjectSupport,
  float: float
};
