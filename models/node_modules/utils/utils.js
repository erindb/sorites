var fs = require('fs');
// var csvtojson = require('csvtojson');
var babyparse = require('babyparse');
var jStat = require('jStat').jStat;

var max = function(arr) {return Math.max.apply(null, arr);};

var min = function(arr) {return Math.min.apply(null, arr);};

function readCSV(filename){
  return babyparse.parse(fs.readFileSync(filename, 'utf8'));
}

function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function closest(arr, closestTo){

    var closest_value = Math.max.apply(null, arr); //Get the highest number in arr in case it match nothing.
    for(var i = 0; i < arr.length; i++){ //Loop the array
        if(arr[i] >= closestTo && arr[i] < closest_value) closest_value = arr[i]; //Check if it's higher than your number, but lower than your closest value
    }
    return closest; // return the value
}

// can work with an erp of query.tables (useful for data analysis models)
var writeQueryERP = function(erp, filename, header) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,header + ',prob\n');
 supp.forEach(function(s) {supportWriter(s, Math.exp(erp.score(s)), csvFile);});
 fs.closeSync(csvFile);
};

var naturalpriorERPWriter = function(erp, filename) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,'Property,Parameter,Value,Probability\n');
 supp.forEach(function(s) {supportWriter(s, Math.exp(erp.score(s)), csvFile);});
 fs.closeSync(csvFile);
};

var naturalcasepriorERPWriter = function(erp, filename) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,'Property,Category,Parameter,Value,Probability\n');
 supp.forEach(function(s) {supportWriter(s, Math.exp(erp.score(s)), csvFile);});
 fs.closeSync(csvFile);
};

var supportWriter = function(s, p, handle) {
 var sLst = _.toPairs(s);
 var l = sLst.length;
 for (var i = 0; i < l; i++) {
   fs.writeSync(handle, sLst[i].join(',')+','+p+'\n');
 }
};

function fillArray(value, len) {
  var arr = [];
  for (var i = 0; i < len; i++) {
    arr.push(value);
  }
  return arr;
}

function wpParseFloat(x){
  return parseFloat(x);
}

function betaCDF(x, params){
  return jStat.beta.cdf( x, params.a, params.b );
}

function uniformCDF(x, params){
  return jStat.uniform.cdf( x, params.a, params.b );
}

function gaussianCDF(x, params){
  return jStat.normal.cdf( x, params.mu, params.sigma );
}
function lognormalCDF(x, params){
  return jStat.lognormal.cdf( x, params.mu, params.sigma );
}

function closest_value(support, value, direction){
  var closest_so_far = support[0];
  for (var i = 0; i<support.length; i++) {
    candidate_value = support[i];
    if (direction=="none" ||
        (direction=="above" && value<candidate_value) ||
        (direction=="below" && candidate_value<value)) {
      var closest_dist = Math.abs(closest_so_far - value);
      var candidate_dist = Math.abs(candidate_value - value);
      if (candidate_dist < closest_dist) {
        closest_so_far = candidate_value;
      }
    }
  }
  return closest_so_far;
}

var get_bins = function(dollar_amounts, n_bins) {
  var max_price = max(dollar_amounts) * 1.5;
  var step_length = max_price / n_bins;
  var bins = [];
  a = 0;
  while (a < max_price) {
    b = a + step_length;
    mid = (a + b) / 2;
    bins.push({a: a, b: b, mid: mid});
    a = b;
  }
  return bins;
};

var bin_value = function(x, bins) {
  for (var i = 0; i < bins.length; i++) {
    var bin = bins[i];
    if (bin.a <= x && x <= bin.b) {
      return bin;
    }
  }
  return bin;
};

module.exports = {
  readCSV: readCSV,
  isNumber: isNumber,
  fillArray: fillArray,
  writeQueryERP: writeQueryERP,
  naturalpriorERPWriter: naturalpriorERPWriter,
  naturalcasepriorERPWriter: naturalcasepriorERPWriter,
  closest: closest,
  wpParseFloat: wpParseFloat,
  betaCDF: betaCDF,
  uniformCDF: uniformCDF,
  gaussianCDF: gaussianCDF,
  lognormalCDF: lognormalCDF,
  max: max,
  min: min,
  closest_value: closest_value,
  get_bins: get_bins,
  isNaN: isNaN,
  bin_value: bin_value
};
