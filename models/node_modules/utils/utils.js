
var jStat = require('jStat').jStat;

var max = function(arr) {return Math.max.apply(null, arr);};
var min = function(arr) {return Math.min.apply(null, arr);};
var sum = function(arr) {return jStat.sum(arr);};

var gaussianCDF = function(x, params){
  return jStat.normal.cdf( x, params.mu, params.sigma );
};

var sort = function(x) {
  x.sort(function(a,b){return a-b;});
  return x;
};

var get_bins = function(dollar_amounts) {
  sort(dollar_amounts)

  var points_of_interest = [0]
    .concat(dollar_amounts)
    .concat(max(dollar_amounts)*1.5);

  var first_bin = {a:0, b:(points_of_interest[1]/2)};
  first_bin.s = "(" + first_bin.a + ", " + first_bin.b + "]";

  var bins = [first_bin].concat(
    _.range(points_of_interest.length-2).map(function(i) {
      var range = {
        a: (points_of_interest[i] + points_of_interest[i+1])/2,
        b: (points_of_interest[i+1] + points_of_interest[i+2])/2
      }
      range.s = "(" + range.a + ", " + range.b + "]";
      return range;
    })
  );

  var last_bin = {a:jStat.mean(points_of_interest.slice(-2)), b: "Infinity"};
  last_bin.s = "(" + last_bin.a + ", " + last_bin.b + ")";
  
  return bins.concat([last_bin]);
};

function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}










var fs = require('fs');
// var csvtojson = require('csvtojson');
var babyparse = require('babyparse');
var jStat = require('jStat').jStat;


function readCSV(filename){
  return babyparse.parse(fs.readFileSync(filename, 'utf8'));
}

// can work with an erp of query.tables (useful for data analysis models)
var writeQueryERP = function(erp, filename, header) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,header + ',prob\n');
 supp.forEach(function(s) {supportWriter(s, Math.exp(erp.score(s)), csvFile);});
 fs.closeSync(csvFile);
};

var naturalpriorERPWriter = function(erp, filename) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,'Property,Parameter,Value,Probability\n');
 supp.forEach(function(s) {supportWriter(s, Math.exp(erp.score(s)), csvFile);});
 fs.closeSync(csvFile);
};

var naturalcasepriorERPWriter = function(erp, filename) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,'Property,Category,Parameter,Value,Probability\n');
 supp.forEach(function(s) {supportWriter(s, Math.exp(erp.score(s)), csvFile);});
 fs.closeSync(csvFile);
};

var supportWriter = function(s, p, handle) {
 var sLst = _.toPairs(s);
 var l = sLst.length;
 for (var i = 0; i < l; i++) {
   fs.writeSync(handle, sLst[i].join(',')+','+p+'\n');
 }
};

function fillArray(value, len) {
  var arr = [];
  for (var i = 0; i < len; i++) {
    arr.push(value);
  }
  return arr;
}

function wpParseFloat(x){
  return parseFloat(x);
}

function betaCDF(x, params){
  return jStat.beta.cdf( x, params.a, params.b );
}

function uniformCDF(x, params){
  return jStat.uniform.cdf( x, params.a, params.b );
}

function lognormalCDF(x, params){
  return jStat.lognormal.cdf( x, params.mu, params.sigma );
}

function closest(arr, closestTo){

    var closest_value = Math.max.apply(null, arr); //Get the highest number in arr in case it match nothing.
    for(var i = 0; i < arr.length; i++){ //Loop the array
        if(arr[i] >= closestTo && arr[i] < closest_value) closest_value = arr[i]; //Check if it's higher than your number, but lower than your closest value
    }
    return closest; // return the value
}
function closest_value(support, value, direction){
  var closest_so_far = support[0];
  for (var i = 0; i<support.length; i++) {
    candidate_value = support[i];
    if (direction=="none" ||
        (direction=="above" && value<candidate_value) ||
        (direction=="below" && candidate_value<value)) {
      var closest_dist = Math.abs(closest_so_far - value);
      var candidate_dist = Math.abs(candidate_value - value);
      if (candidate_dist < closest_dist) {
        closest_so_far = candidate_value;
      }
    }
  }
  return closest_so_far;
}

function get_closest_values(support, value, direction){
  support.sort();
  if (support.length == 0) {
    return null;
  } else {
    var upper = support[0];
    var lower = support[support.length - 1];
    if (support.length > 2) {
    }
    return [upper, lower];
  }
}

var bin_value = function(x, bins) {
  for (var i = 0; i < bins.length; i++) {
    var bin = bins[i];
    if (bin.a <= x && x <= bin.b) {
      return bin;
    }
  }
  return bin;
};

module.exports = {
  readCSV: readCSV,
  isNumber: isNumber,
  fillArray: fillArray,
  writeQueryERP: writeQueryERP,
  naturalpriorERPWriter: naturalpriorERPWriter,
  naturalcasepriorERPWriter: naturalcasepriorERPWriter,
  closest: closest,
  wpParseFloat: wpParseFloat,
  betaCDF: betaCDF,
  uniformCDF: uniformCDF,
  gaussianCDF: gaussianCDF,
  lognormalCDF: lognormalCDF,
  max: max,
  min: min,
  closest_value: closest_value,
  get_bins: get_bins,
  isNaN: isNaN,
  bin_value: bin_value,
  get_closest_values: get_closest_values
};
