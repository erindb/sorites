var fs = require('fs');
// var csvtojson = require('csvtojson');
var babyparse = require('babyparse');
var jStat = require('jStat').jStat;

function readCSV(filename) {
  return babyparse.parse(fs.readFileSync(filename, 'utf8'));
}
function max(arr) {return Math.max.apply(null, arr);};
function min(arr) {return Math.min.apply(null, arr);};
function sum(arr) {return jStat.sum(arr);};

function betaCDF(x, params){
  return jStat.beta.cdf( x, params.a, params.b );
}

function uniformCDF(x, params){
  return jStat.uniform.cdf( x, params.a, params.b );
}

function gaussianCDF(x, params){
  return jStat.normal.cdf( x, params.mu, params.sigma );
}

function lognormalCDF(x, params){
  return jStat.lognormal.cdf( x, params.mu, params.sigma );
}

function sort(x) {
  x.sort(function(a,b){return a-b;});
  return x;
}

function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

function closest(arr, closestTo){
  var closest = Math.max.apply(null, arr); //Get the highest number in arr in case it match nothing.
  for(var i = 0; i < arr.length; i++) { //Loop the array
    if(arr[i] >= closestTo && arr[i] < closest) closest = arr[i]; //Check if it's higher than your number, but lower than your closest value
    function find_bin(x, bins) {
      for (var i=0; i<bins.length; i++) {
        var bin = bins[i];
        if (bin.b == "Infinity") {
          return i;
        } else if (bin.a <= x && x <= bin.b) {
          return i;
        }
        return closest; // return the value
      }
    }
  }
}

function numeric(a,b) {
  return a-b;
}

var get_variable = function(tag) {
  for (var i = 0; i < process.argv.length; i++) {
    if (process.argv[i] == tag) {
      return process.argv[i+1];
    }
  }
};

var get_flag = function(tag) {
  for (var i = 0; i < process.argv.length; i++) {
    if (process.argv[i] == tag) {
      return true;
    }
  }
  return false;
};


function median(a,b) {
  // Make sure that a is less than b.
  if (b < a) {
    var tmp_a = a;
    var tmp_b = b;
    a = tmp_b;
    b = tmp_a;
  }
  return (b-a)/2 + a;
}

function double_precision(dollar_amounts) {
  var new_dollar_amounts = [];
  var previous_dollar_amount = 0;
  for (var i=0; i<dollar_amounts.length; i++) {
    var current_dollar_amount = dollar_amounts[i];
    new_dollar_amounts.push(median(
      previous_dollar_amount,
      current_dollar_amount==Infinity ? max_theta : current_dollar_amount
    ));
    new_dollar_amounts.push(current_dollar_amount);
    previous_dollar_amount = current_dollar_amount;
  }
  return new_dollar_amounts;
}

function even_bins(dollar_amounts) {
  dollar_amounts.sort(numeric);
  var max_dollar_amount = dollar_amounts[dollar_amounts.length - 1];

  var previous_dollar_amount = 0;
  var min_dist = max_dollar_amount;
  for (var i=0; i<dollar_amounts.length; i++) {
    var dist = dollar_amounts[i] - previous_dollar_amount;
    if (dist < min_dist) {
      min_dist = dist;
    }
  }

  var n_bins = _.round(max_dollar_amount/min_dist) + 2;

  // Initialize all bin values;
  var lowerBins = [];
  var upperBins = [];
  var midBins = [];
  var thetaBins = [];
  var thetaProbs = [];
  var dollar_amount_lookups = {};

  var next_dollar_amount_index = 0;

  var cutoff_below = 0;
  var cutoff_above = null;
  var mid = null;
  var previous_mid = 0;
  var theta = null;
  var theta_prob = null;

  for (var i=0; i<n_bins; i++) {
    lowerBins.push(cutoff_below);

    cutoff_above = cutoff_below + min_dist;
    upperBins.push(cutoff_above);

    mid = median(cutoff_below, cutoff_above);
    midBins.push(mid);

    next_dollar_amount = dollar_amounts[next_dollar_amount_index];
    if (cutoff_below<next_dollar_amount && next_dollar_amount<cutoff_above) {
      dollar_amount_lookups[next_dollar_amount] = mid;
      next_dollar_amount_index++;
    }

    // TODO finish this.

    // // Let the highest bin's midpoint be at the max value of theta.
    // if (current_midpoint==Infinity) {
    //   current_midpoint = max_theta;
    // }
    // // Thetas should be between bins.
    // theta = cutoff_below;
    // // The probability of a theta being sampled that's between a given pair of
    // // bins is proportional to the length of the interval between the midpoints.
    // theta_prob = (current_midpoint - previous_midpoint)/max_theta;
  }

}

function bins(dollar_amounts) {
  // Sort dollar amounts so bins are sequential.
  dollar_amounts.sort(numeric);

  // Give threshold a generous maximum value.
  var max_theta = 1.1*dollar_amounts[dollar_amounts.length-1];

  // Add a few bins below the lowest dollar amount.
  var min_dollar_amount = dollar_amounts[0];
  var lower_dollar_amounts = _.map([0.5], function(x) {
    return x*min_dollar_amount
  });
  dollar_amounts = lower_dollar_amounts.concat(dollar_amounts);

  // Add a few bins above the highest dollar amount.
  var max_dollar_amount = dollar_amounts[dollar_amounts.length-1];
  var higher_dollar_amounts = _.map([0.5], function(x) {
    return x*(max_theta - max_dollar_amount) + max_dollar_amount;
  })
  dollar_amounts = dollar_amounts.concat(higher_dollar_amounts);

  // // Add more bins in between each of the dollar amounts in this experiment.
  // dollar_amounts = double_precision(dollar_amounts);
  // dollar_amounts = double_precision(dollar_amounts);
  // dollar_amounts = double_precision(dollar_amounts);

  // Initialize all bin values;
  var lowerBins = [];
  var upperBins = [];
  var midBins = [];
  var thetaBins = [];
  var thetaProbs = [];
  var dollar_amount_lookups = {};
  var theta_lookups = {};

  // Iterate through dollar amounts to construct bins.
  var cutoff_below = 0;
  var cutoff_above = null;
  var current_dollar_amount = null;
  var next_dollar_amount = null;
  var previous_midpoint = 0;
  var current_midpoint = null;
  var theta = null;
  var theta_prob = null;
  for (var i = 0; i < dollar_amounts.length; i++) {
    // Each bin should contain the current dollar amount.
    current_dollar_amount = dollar_amounts[i];
    // Its upper value should be between this dollar amount and the next one.
    // Bins might be different widths.
    if (i == (dollar_amounts.length-1)) {
      cutoff_above = Infinity;
    } else {
      next_dollar_amount = dollar_amounts[i+1];
      cutoff_above = median(current_dollar_amount, next_dollar_amount);
    }
    // The midpoint of the bin is between the upper and lower cutoffs.
    // (This is not necessarily the current dollar amount.)
    current_midpoint = median(cutoff_below, cutoff_above);
    // Let the highest bin's midpoint be at the max value of theta.
    if (current_midpoint==Infinity) {
      current_midpoint = max_theta;
    }
    // Thetas should be between bins.
    theta = cutoff_below;
    // The probability of a theta being sampled that's between a given pair of
    // bins is proportional to the length of the interval between the midpoints.
    var theta_upper = current_midpoint;
    var theta_lower = previous_midpoint;
    theta_prob = (theta_upper - theta_lower)/max_theta;
    theta_lookups[theta] = {lower: theta_lower, upper: theta_upper};

    lowerBins.push(cutoff_below);
    upperBins.push(cutoff_above);
    midBins.push(current_midpoint);
    thetaBins.push(theta);
    thetaProbs.push(theta_prob);
    dollar_amount_lookups[current_dollar_amount] = current_midpoint;

    cutoff_below = cutoff_above;
    previous_midpoint = current_midpoint;
  }

  return {
    "mid": midBins,
    "lower": lowerBins,
    "upper": upperBins,
    "theta": thetaBins,
    "theta_prob": thetaProbs,
    "dollar_amount_lookups": dollar_amount_lookups,
    "theta_lookups": theta_lookups
  }
}

function max_theta(bins) {
  var theta_max = 0;
  for (var i = 0; i<bins.length; i++) {
    var bin = bins[i];
    if (bin.a > theta_max) {
      theta_max = bin.a;
    }
  }
  return 1.5*theta_max;
}


// can work with an erp of query.tables (useful for data analysis models)
var writeQueryERP = function(erp, filename, header) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,header + ',prob\n')
 supp.forEach(function(s) {
   supportWriter(s, Math.exp(erp.score(s)), csvFile);
 })
 fs.closeSync(csvFile);
};

var naturalpriorERPWriter = function(erp, filename) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,'Property,Parameter,Value,Probability\n')
 supp.forEach(function(s) {supportWriter(s, Math.exp(erp.score(s)), csvFile);})
 fs.closeSync(csvFile);
}

var naturalcasepriorERPWriter = function(erp, filename) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,'Property,Category,Parameter,Value,Probability\n')
 supp.forEach(function(s) {supportWriter(s, Math.exp(erp.score(s)), csvFile);})
 fs.closeSync(csvFile);
}

var writeLstOfObjectSupport = function(erp, filename, header) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,header + ',prob\n')
 supp.forEach(function(s) {lstObjectSupportWriter(s, Math.exp(erp.score(s)), csvFile);})
 fs.closeSync(csvFile);
};

var lstObjectSupportWriter = function(s, p, handle) {
 // var sLst = _.toPairs(s);
 var l = s.length;
 for (var i = 0; i < l; i++) {
   fs.writeSync(handle, _.values(s[i]).join(',')+','+p+'\n');
 }
};


var supportWriter = function(s, p, handle) {
 var sLst = _.toPairs(s);
 var l = sLst.length;
 for (var i = 0; i < l; i++) {
   // console.log(sLst[i].join(','))
   fs.writeSync(handle, sLst[i].join(',')+','+p+'\n');
 }
};

function fillArray(value, len) {
  var arr = [];
  for (var i = 0; i < len; i++) {
    arr.push(value);
  }
  return arr;
};

function wpParseFloat(x){
  return parseFloat(x);
};

function betaCDF(x, params){
  return jStat.beta.cdf( x, params.a, params.b )
}

function uniformCDF(x, params){
  return jStat.uniform.cdf( x, params.a, params.b )
}

function gaussianCDF(x, params){
  return jStat.normal.cdf( x, params.mu, params.sigma )
}
function lognormalCDF(x, params){
  return jStat.lognormal.cdf( x, params.mu, params.sigma )
}

var LOG_2PI = 1.837877066409345483560659472811235279722794947275566825;
function lognormalScore(x, params) {
  var mu = params.mu;
  var sigma = params.sigma;
  var logx = Math.log(x);
  return (
    - logx
    - Math.log(sigma)
    - 0.5 * (
      LOG_2PI + (logx - mu) * (logx - mu) / (sigma * sigma)
    )
  )
};

function readCSV(filename){
  return babyparse.parse(fs.readFileSync(filename, 'utf8'));
};

function writeCSV(jsonCSV, filename){
  fs.writeFileSync(filename, babyparse.unparse(jsonCSV) + "\n");
}

function writeJSON(x, filename) {
  fs.writeFileSync(filename, JSON.stringify(x, undefined, indent=2) + "\n");
}


var openFile = function(filename) {
 var csvFile = fs.openSync(filename, 'w');
 return csvFile
};

var closeFile = function(handle){
 fs.closeSync(handle);
};


var writeLine = function(handle, line){
  fs.writeSync(handle, line+'\n');
};

var saveERP = function(erp, extraColumns, handle) {
   // var handle = openFile(file);
   var supp = erp.support();
   supp.forEach(function(s) {writeLine(handle, extraColumns.concat([s, Math.exp(erp.score(s))]));})
   // closeFile(handle)
};

var float = function(x) {
  return parseFloat(x);
};

var cor = function(x, y) {return jStat.corrcoeff( x, y );};

module.exports = {
  saveERP: saveERP,
  openFile: openFile,
  closeFile: closeFile,
  writeLine: writeLine,
  writeCSV: writeCSV,
  writeJSON: writeJSON,
  readCSV: readCSV,
  isNumber: isNumber,
  fillArray: fillArray,
  writeQueryERP: writeQueryERP,
  naturalpriorERPWriter: naturalpriorERPWriter,
  naturalcasepriorERPWriter: naturalcasepriorERPWriter,
  wpParseFloat: wpParseFloat,
  bins: bins,
  betaCDF: betaCDF,
  uniformCDF: uniformCDF,
  gaussianCDF: gaussianCDF,
  lognormalCDF: lognormalCDF,
  lognormalScore: lognormalScore,
  writeLstOfObjectSupport: writeLstOfObjectSupport,
  float: float,
  max_theta: max_theta,
  max: max,
  min: min,
  isNaN: isNaN,
  get_variable: get_variable,
  get_flag: get_flag,
  cor: cor
};
