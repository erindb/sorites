
var jStat = require('jStat').jStat;

function max(arr) {return Math.max.apply(null, arr);};
function min(arr) {return Math.min.apply(null, arr);};
function sum(arr) {return jStat.sum(arr);};

function betaCDF(x, params){
  return jStat.beta.cdf( x, params.a, params.b );
}

function uniformCDF(x, params){
  return jStat.uniform.cdf( x, params.a, params.b );
}

function gaussianCDF(x, params){
  return jStat.normal.cdf( x, params.mu, params.sigma );
}

function lognormalCDF(x, params){
  return jStat.lognormal.cdf( x, params.mu, params.sigma );
}

function sort(x) {
  x.sort(function(a,b){return a-b;});
  return x;
}

function get_bins(dollar_amounts) {
  sort(dollar_amounts)

  var points_of_interest = [0]
    .concat(dollar_amounts)
    .concat(max(dollar_amounts)*1.5);

  var first_bin = {a:0, b:(points_of_interest[1]/2)};
  first_bin.s = "(" + first_bin.a + ", " + first_bin.b + "]";

  var bins = [first_bin].concat(
    _.range(points_of_interest.length-2).map(function(i) {
      var range = {
        a: (points_of_interest[i] + points_of_interest[i+1])/2,
        b: (points_of_interest[i+1] + points_of_interest[i+2])/2
      }
      range.s = "(" + range.a + ", " + range.b + "]";
      return range;
    })
  );

  var last_bin = {a:jStat.mean(points_of_interest.slice(-2)), b: "Infinity"};
  last_bin.s = "(" + last_bin.a + ", " + last_bin.b + ")";

  return bins.concat([last_bin]);
}

function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

function find_bin(x, bins) {
  for (var i=0; i<bins.length; i++) {
    var bin = bins[i];
    if (bin.b == "Infinity") {
      return i;
    } else if (bin.a <= x && x <= bin.b) {
      return i;
    }
  }
  console.log("ERROR 124: no bins for this number!")
}

function max_theta(bins) {
  var theta_max = 0;
  for (var i = 0; i<bins.length; i++) {
    var bin = bins[i];
    if (bin.a > theta_max) {
      theta_max = bin.a;
    }
  }
  return 1.5*theta_max;
}


var fs = require('fs');
// var csvtojson = require('csvtojson');
var babyparse = require('babyparse');

function readCSV(filename){
  return babyparse.parse(fs.readFileSync(filename, 'utf8'));
}

// can work with an erp of query.tables (useful for data analysis models)
var writeQueryERP = function(erp, filename, header) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,header + ',prob\n');
 supp.forEach(function(s) {supportWriter(s, Math.exp(erp.score(s)), csvFile);});
 fs.closeSync(csvFile);
};

var naturalpriorERPWriter = function(erp, filename) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,'Property,Parameter,Value,Probability\n');
 supp.forEach(function(s) {supportWriter(s, Math.exp(erp.score(s)), csvFile);});
 fs.closeSync(csvFile);
};

var naturalcasepriorERPWriter = function(erp, filename) {
 var supp = erp.support();
 var csvFile = fs.openSync(filename, 'w');
 fs.writeSync(csvFile,'Property,Category,Parameter,Value,Probability\n');
 supp.forEach(function(s) {supportWriter(s, Math.exp(erp.score(s)), csvFile);});
 fs.closeSync(csvFile);
};

var supportWriter = function(s, p, handle) {
 var sLst = _.toPairs(s);
 var l = sLst.length;
 for (var i = 0; i < l; i++) {
   fs.writeSync(handle, sLst[i].join(',')+','+p+'\n');
 }
};

function fillArray(value, len) {
  var arr = [];
  for (var i = 0; i < len; i++) {
    arr.push(value);
  }
  return arr;
}

function wpParseFloat(x){
  return parseFloat(x);
}

module.exports = {
  readCSV: readCSV,
  isNumber: isNumber,
  find_bin: find_bin,
  fillArray: fillArray,
  writeQueryERP: writeQueryERP,
  naturalpriorERPWriter: naturalpriorERPWriter,
  naturalcasepriorERPWriter: naturalcasepriorERPWriter,
  wpParseFloat: wpParseFloat,
  betaCDF: betaCDF,
  uniformCDF: uniformCDF,
  gaussianCDF: gaussianCDF,
  lognormalCDF: lognormalCDF,
  max_theta: max_theta,
  max: max,
  min: min,
  get_bins: get_bins,
  isNaN: isNaN
};
