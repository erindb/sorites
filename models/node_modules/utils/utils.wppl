var responseDictionary = { "agree-key": 1, "disagree-key": 0 };
var eps = Number.EPSILON;

var removeExtraRow = function(lst){
  return lst.slice(0, lst.length - 1)
}

var levels = function(df, label){
  return _.uniq(_.map(df, label));
}

var roundTo3 = function(x){
  return Math.round(x * 10000) / 10000
}
var exp = function(x){ return Math.exp(x); };

var probability = function(Dist, x) {
    return exp(Dist.score(x));
}

var setup_bins = function(d_sorites, ids, item) {
  return _.fromPairs(map(function(id) {
    var d = id=="all" ? (_.filter(d_sorites,
      {"qtype": "concrete", "object": item}
    )) : (_.filter(d_sorites,
      {"id": id, "qtype": "concrete", "object": item}
    ));

    var dollar_amounts = map(function(x) {
      return utils.float(x);
    }, levels(d, "dollar_amount"));

    return [id, utils.bins(dollar_amounts)];
  }, ids.concat(["all"])))
}

var foreach = function(lst, fn) {
    var foreach_ = function(i) {
        if (i < lst.length) {
            fn(lst[i]);
            foreach_(i + 1);
        }
    };
    foreach_(0);
};

var DiscretizedLognormal = function(lognormalParams, bins) {
  var midBins = bins["mid"];
  var lowerBins = bins["lower"];
  var upperBins = bins["upper"];
  return Categorical({
    vs: midBins,
    ps: map2(function(b1, b2) {
      // TODO if b2 is infinity
      var mass_up_to_b2 = utils.lognormalCDF(b2, lognormalParams);
      var mass_below_b1 = utils.lognormalCDF(b1, lognormalParams);
      return eps + mass_up_to_b2 - mass_below_b1;
    }, lowerBins, upperBins)
  });
};

var DiscretizedJointUnifLognormal = function(lognormalParams, bins) {
  var midBins = bins["mid"];
  var lowerBins = bins["lower"];
  var upperBins = bins["upper"];
  var thetaBins = bins["theta"];
  var thetaProbs = bins["theta_prob"];
  var val_dist = Categorical({
    vs: midBins,
    ps: map2(function(b1, b2) {
      // TODO if b2 is infinity
      var mass_up_to_b2 = utils.lognormalCDF(b2, lognormalParams);
      var mass_below_b1 = utils.lognormalCDF(b1, lognormalParams);
      return eps + mass_up_to_b2 - mass_below_b1;
    }, lowerBins, upperBins)
  });
  var theta_dist = Categorical({vs: thetaBins, ps: thetaProbs});
  return Infer({method: "enumerate"}, function() {
    var x = sample(val_dist);
    var theta = sample(theta_dist);
    // return JSON.stringify([x, theta]);
    return [x,theta];
  });
};














var responseDictionary = { "agree-key": 1, "disagree-key": 0 };

var roundTo3 = function(x){
  return Math.round(x * 10000) / 10000
}

var nearestPriorBin = function(x, bns){
  return x > _.max(bns) ?
      _.max(bns) :
      x < _.min(bns) ?
      _.min(bns) :
      bns[Math.round(((x - _.min(bns))/(_.max(bns) - _.min(bns)))*(bns.length-1))]
}

var betaShape = function(p){
  return {a: p.g * p.d, b: (1-p.g) * p.d}
};


var avoidEnds = function(response){
    return response==0 ? 0.001 : response==1 ? 0.999 : response
}

var distProbs = function(dist, supp) {
  return map(function(s) {
    return Math.exp(dist.score(s))
  }, supp)
}

var KL = function(p, q, supp) {
  var P = distProbs(p, supp), Q = distProbs(q, supp);
  var diverge = function(xp,xq) {
    return xp == 0 ? 0 : (xp * Math.log(xp / xq) );
  };
  return sum(map2(diverge,P,Q));
};

var marginalize = function(myDist, label){
    Infer({method: "enumerate"}, function(){
        var x = sample(myDist);
        return x[label]
    });
};

var dataFrame = function(d, fieldsToNumerify){
    return removeExtraRow(map(
        function(lst){
            return _.fromPairs(map(function(l){
                return _.indexOf(fieldsToNumerify, l[0]) > -1 ?
                            [l[0], utils.wpParseFloat(l[1])] : l
            },
            _.zip(d[0],lst)
            ))
        },
        d.slice(1)))
}

var displayObj = function(x){
  display(JSON.stringify(x))
}


var dataPath = "../data/";

var readDataFile = function(fileType, filePrefix){
  var fileName = dataPath + fileType + "/"+filePrefix+"/"+filePrefix+"-trials.csv";
  return dataFrame(utils.readCSV(fileName).data, ["workerid","response", "prevalence_level"])
}

var readCatchFile = function(fileType, filePrefix){
  var fileName = dataPath + fileType + "/"+filePrefix+"/"+filePrefix+"-catch_trials.csv";
  return dataFrame(utils.readCSV(fileName).data, ["workerid", "tested_on", "correct"])
}

var readSubjFile = function(fileType, filePrefix){
  var fileName = dataPath + fileType + "/"+filePrefix+"/"+filePrefix+"-subject_information.csv";
  return dataFrame(utils.readCSV(fileName).data, ["workerid"])
}

var passCatchTrials = function(df){
  var workerids = levels(df, "workerid");
  return filter(function(workerid){
    var subjCatchTrials = _.filter(df, {workerid: workerid});
    return all(function(tested_on){
      // check that at least 4 out of 5 correct rejections and 4 out of 5 hits
      return sum(_.map(_.filter(subjCatchTrials, {tested_on: tested_on}), "correct")) >= 4
    }, [0,1])
  }, workerids)
}

var passCatchPriorManipTrials = function(df){
  var workerids = levels(df, "workerid");
  return filter(function(workerid){
    var subjCatchTrials = _.filter(df, {workerid: workerid});
    return subjCatchTrials[0].pass_both == 1;
  }, workerids)
}


var nativeEnglish = function(df){
  var workerids = levels(df, "workerid");
  return filter(function(workerid){
    var subjInfo = _.filter(df, {workerid: workerid});
    return subjInfo[0]["language"].toLowerCase().indexOf("eng") > -1
  }, workerids)
}
