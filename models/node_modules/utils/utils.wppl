
var eps = Number.EPSILON;

// Get all unique values of a factor.
var levels = function(df, label){
  return _.uniqBy(_.map(df, label));
};

// Same # digits as webppl/src/math/numeric.ad.js
var LOG_2PI = 1.8378770664093453

// Erin, if this doesn't make sense, see "mistakes_i_made.Rmd"
// Log of lognormal density.
var lognormal_score = function(x, params) {
  var mu = params.mu;
  var sigma = params.sigma;
  return ((-Math.log(x)) +
          (-Math.log(sigma)) +
          (-0.5*LOG_2PI) +
          (-( Math.pow((Math.log(x) - mu), 2) /
              (2 * Math.pow(sigma, 2)) )));
};

// Construct a single row in the output dataframe.
// (For interfacing with R)
var add_output_datapoint = function(key, val) {
  var basic_key = {
    type: "NA",
    label: "NA",
    dollar_amount: "NA",
    object: "NA",
  };
  var new_key = _.extend(basic_key, key);
  var keystring = JSON.stringify(new_key);
  query.add(keystring, _.clone(val));
};

var exp = function(x){ return Math.exp(x); };

var log = function(x) {
  if (x=="Infinity") {
    return "Infinity";
  } else if (x==0) {
    return "-Infinity";
  } else {
    return Math.log(x);
  }
};

var probability = function(Dist, x) {
    return exp(Dist.score(x));
};

// Super complicated joint probability distribution.
// if this seems weird, go look at discretization.html
var DiscretizedJointLognormalUniform = function(gaussianParams, bins){
  var mu = gaussianParams.mu;
  var sigma = gaussianParams.sigma;

  var max_theta = 1.5*reduce(function(x, acc) {
    if (x.a > acc) {
      return x.a;
    } else {
      return acc;
    }
  }, 0, bins);

  var values = reduce(function(xbin, accx) {
    return accx.concat(reduce(function(thetabin, acctheta) {
      if (xbin.s == thetabin.s) {
        return acctheta.concat([
          {x: xbin, theta: thetabin, dir: "theta < x"},
          {x: xbin, theta: thetabin, dir: "x <= theta"},
        ]);
      } else {
        return acctheta.concat([
          {x: xbin, theta: thetabin, dir: "NA"}
        ]);
      }
    }, [], bins));
  }, [], bins);

  // How to calculate joint probability when x and theta fall in different ranges
  var different_ranges = function(v) {
    // different ranges
    var theta_upper = (v.theta.b == "Infinity") ? max_theta : v.theta.b;
    var ptheta = (theta_upper - v.theta.a) / max_theta;
    var px = (utils.gaussianCDF(log(v.x.b), gaussianParams) -
              utils.gaussianCDF(log(v.x.a), gaussianParams));
    return (px * ptheta);
  };

  // How to calculate joint probability when x and theta vall in the same
  // range and theta falls BELOW x.
  var theta_below_x = function(v) {
    if (v.x.b == "Infinity" || max_theta < v.x.b) {
      // x could be above the range of theta,
      // so we should NOT calculate THETA's probability mass all the
      // way up to v.x.b
      return(
        // joint prob where regions overlap
        // if theta < x < max_theta < b:
        (1/max_theta) *
        (Math.exp(0.5*sigma*sigma + mu)) *
        (utils.gaussianCDF(log(max_theta),
                     {mu: sigma*sigma+mu, sigma: sigma}) -
         utils.gaussianCDF(log(v.x.a),
                     {mu: sigma*sigma+mu, sigma: sigma}))
        -
        (v.x.a/max_theta)*
        (utils.gaussianCDF(log(max_theta), gaussianParams) -
         utils.gaussianCDF(log(v.x.a), gaussianParams))
        +
        // join prob where x is above theta's max value
        // if theta < max_theta < x < b:
        ((max_theta - v.x.a)/max_theta) *
        (utils.gaussianCDF(log(v.x.b), gaussianParams) -
         utils.gaussianCDF(log(max_theta), gaussianParams))
      );
    } else {
      // if theta < x < b < max_theta:
      // then both x and theta can range all the way from a to b
      return (
        (1/max_theta) *
        (Math.exp(0.5*sigma*sigma + mu)) *
        (utils.gaussianCDF(log(v.x.b),
                     {mu: sigma*sigma+mu, sigma: sigma}) -
         utils.gaussianCDF(log(v.x.a),
                     {mu: sigma*sigma+mu, sigma: sigma}))
        -
        (v.x.a/max_theta)*
        (utils.gaussianCDF(log(v.x.b), gaussianParams) -
         utils.gaussianCDF(log(v.x.a), gaussianParams))
      );
    }
  };

  // How to calculate joint probability when x and theta vall in the same
  // range and theta falls ABOVE x.
  var theta_above_x = function(v) {
    // if x is less than theta, then both x and theta are less than max_theta
    var B = ((v.x.b == "Infinity") ?
             max_theta :
             ((max_theta < v.x.b) ?
              max_theta :
              v.x.b));
    return (
      (B/max_theta) *
      (utils.gaussianCDF(log(B), gaussianParams) -
       utils.gaussianCDF(log(v.x.a), gaussianParams))
      -
      (1/max_theta) *
      (Math.exp(0.5*sigma*sigma + mu)) *
      (utils.gaussianCDF(log(B), {mu: sigma*sigma + mu, sigma: sigma}) -
       utils.gaussianCDF(log(v.x.a), {mu: sigma*sigma + mu, sigma: sigma}))
    );
  };

  // Joint probability for each combination of ranges and relations
  var probabilities = map(function(v) {
    if (v.x.s == v.theta.s) {
      // x and theta fall in the same range, so we
      // need to keep track of which is greater
      if (v.dir == "theta < x") {
        return theta_below_x(v);
      } else if (v.dir == "x <= theta") {
        return theta_above_x(v);
      } else {
        display("ERROR 213049");
      }
    } else {
      return different_ranges(v);
    }
  }, values);

  return Infer({method: "enumerate", model: function(){
    return categorical({
      vs: map(function(v) {return {x: v.x.s, theta: v.theta.s, dir: v.dir}}, values),
      ps: map(function(p) {return eps + p;}, probabilities)
    })
  }})
};













var responseDictionary = { "agree-key": 1, "disagree-key": 0 };
var eps = Number.EPSILON;

var roundTo3 = function(x){
  return Math.round(x * 10000) / 10000
}

// DECIDE: Currently, lowest non-0 rate is 1/"5 years"
// lowest in expt: 3 / "5 years" (do we need to go so low?)
// var lowerBound = -2, upperBound = 6, binWidth = 0.4;
var lowerBound = -2.5, upperBound = 9, binWidth = 0.5;

// scale: number of times / year
// var upperBins = map(
// 	function(i){ Math.exp(i) / 5},
// 	_.range(lowerBound, upperBound, binWidth))

// var upperBins = [0.2, 0.6, 1, 1.5, 3, 6, 12, 18, 24, 36, 52, 78, 104, 156, 208, 260, 365]

// var upperBins = map(exp, _.range(lowerBound, upperBound, binWidth))
// var lowerBins = [0].concat(upperBins.slice(0, upperBins.length - 1))

var upperBins =  _.range(
  lowerBound, upperBound, binWidth
)
var lowerBins = [lowerBound - binWidth].concat(
  upperBins.slice(0, upperBins.length - 1)
)


// for FF prior
// var upperBins = _.range(lowerBound + binWidth, upperBound + binWidth, binWidth);
// var lowerBins = [lowerBound].concat(upperBins.slice(0, upperBins.length - 1))

var midBins = map2(function(b1,b2){
  var diff = Math.abs(b2 - b1) / 2;
  return roundTo3(b1 + diff)
}, lowerBins, upperBins)

var thetaBins = map2(function(b1, b2){
  var diff = Math.abs(b2 - b1) / 2;
  return roundTo3(diff+ b1);
}, midBins.slice(0, midBins.length-1), midBins.slice(1))

var DiscretizedLognormal = function(gaussianParams){
	return Infer({model: function(){
    return categorical({
      vs: midBins,
      ps: map2(function(b1, b2){
        return eps +
        utils.lognormalCDF(b2, gaussianParams) -
        utils.lognormalCDF(b1, gaussianParams)
      }, lowerBins, upperBins)
    })
  }})
};

var DiscretizedGaussian = function(gaussianParams){
	return Infer({model: function(){
    return categorical({
      vs: midBins,
      ps: map2(function(b1, b2){
        return eps +
        utils.gaussianCDF(b2, gaussianParams) -
        utils.gaussianCDF(b1, gaussianParams)
      }, lowerBins, upperBins)
    })
  }})
}


// var thetaPrior = Infer({model: function(){
//     return categorical({
//           vs: thetaBins,
//           ps: map2(function(b1, b2){
//             return utils.uniformCDF(b2, {a:0,b:last(midBins)}) -
//             utils.uniformCDF(b1, {a:0, b:last(midBins)})
//           }, midBins.slice(0, midBins.length-1),
//             midBins.slice(1))
//         })
// }})

var thetaPrior = Infer({model: function(){
  return uniformDraw(thetaBins)
}})

var nearestPriorBin = function(x, bns){
  return x > _.max(bns) ?
      _.max(bns) :
      x < _.min(bns) ?
      _.min(bns) :
      bns[Math.round(((x - _.min(bns))/(_.max(bns) - _.min(bns)))*(bns.length-1))]
}

var betaShape = function(p){
  return {a: p.g * p.d, b: (1-p.g) * p.d}
};


var avoidEnds = function(response){
    return response==0 ? 0.001 : response==1 ? 0.999 : response
}

var foreach = function(lst, fn) {
    var foreach_ = function(i) {
        if (i < lst.length) {
            fn(lst[i]);
            foreach_(i + 1);
        }
    };
    foreach_(0);
};

var distProbs = function(dist, supp) {
  return map(function(s) {
    return Math.exp(dist.score(s))
  }, supp)
}

var KL = function(p, q, supp) {
  var P = distProbs(p, supp), Q = distProbs(q, supp);
  var diverge = function(xp,xq) {
    return xp == 0 ? 0 : (xp * Math.log(xp / xq) );
  };
  return sum(map2(diverge,P,Q));
};

var marginalize = function(myDist, label){
    Infer({method: "enumerate"}, function(){
        var x = sample(myDist);
        return x[label]
    });
};

var dataFrame = function(d, fieldsToNumerify){
    return map(
        function(lst){
            return _.fromPairs(map(function(l){
                return _.indexOf(fieldsToNumerify, l[0]) > -1 ?
                            [l[0], utils.wpParseFloat(l[1])] : l
            },
            _.zip(d[0],lst)
            ))
        },
        d.slice(1))
}

var displayObj = function(x){ display(JSON.stringify(x)) }



//////////////////////////////////////////
// helpers (move to package?)//////////
var foreach = function(lst, fn) {
  var foreach_ = function(i) {
    if (i < lst.length) {
      fn(lst[i]);
      foreach_(i + 1);
    }
  };
  foreach_(0);
};

var EPS = Number.EPSILON;

// Truth value function for possible utterances.
var meaning = function(utt, state, theta) {
  return (utt == "expensive" ? state > theta :
          (utt == "not expensive" ? state <= theta :
           (utt == "cheap" ? state < theta :
            (utt == "silence" ? true : true))));
};

var get_score_based_on_nearby_values = function(erp, value) {
  var support = erp.support();
  var closest_values = utils.get_closest_values(support, value);
  if (closest_values == null) {
    display("error 1234");
  }
  var upper = closest_values[0];
  var lower = closest_values[1];
  return (erp.score(upper) + erp.score(lower)) / 2
};



