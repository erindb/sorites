
var eps = Number.EPSILON;

// Get all unique values of a factor.
var levels = function(df, label){
  return _.uniqBy(_.map(df, label));
};

// Same # digits as webppl/src/math/numeric.ad.js
var LOG_2PI = 1.8378770664093453

// Erin, if this doesn't make sense, see "mistakes_i_made.Rmd"
// Log of lognormal density.
var lognormal_score = function(x, params) {
  var mu = params.mu;
  var sigma = params.sigma;
  return ((-Math.log(x)) +
          (-Math.log(sigma)) +
          (-0.5*LOG_2PI) +
          (-( Math.pow((Math.log(x) - mu), 2) /
              (2 * Math.pow(sigma, 2)) )));
};


// // Construct a single row in the output dataframe.
// // (For interfacing with R)
// var add_output_datapoint = function(key, val) {
//   var basic_key = {
//     type: "NA",
//     label: "NA",
//     dollar_amount: "NA",
//     object: "NA",
//   };
//   var new_key = _.extend(basic_key, key);
//   var keystring = JSON.stringify(new_key);
//   query.add(keystring, _.clone(val));
// };

// Construct a single row in the output dataframe.
// (For interfacing with R)
var add_output_datapoint = function(key, val) {
  var basic_key = {
    type: "NA",
    label: "NA",
    dollar_amount: "NA",
    object: "NA",
  };
  var new_key = _.extend(basic_key, key);
  var keystring = [
    new_key.type,
    new_key.label,
    new_key.dollar_amount,
    new_key.object
  ].join("\t");
  query.add(keystring, _.clone(val));
};

var exp = function(x){ return Math.exp(x); };

var log = function(x) {
  if (x=="Infinity") {
    return "Infinity";
  } else if (x==0) {
    return "-Infinity";
  } else {
    return Math.log(x);
  }
};

var probability = function(Dist, x) {
    return exp(Dist.score(x));
};

var DiscretizedLognormal = function(gaussianParams, bins){
  return Infer({model: function(){
    return categorical({
      vs: _.range(bins.length),//map(function(x) {return x.a;}, bins),
      ps: map(function(x) {
        if (x.b == "Infinity") {
          return eps + 1 - utils.lognormalCDF(x.a, gaussianParams);
        } else {
          return eps + utils.lognormalCDF(x.b, gaussianParams) -
          utils.lognormalCDF(x.a, gaussianParams);
        }
      }, bins)
    });
  }});
};

var DiscretizedUniform = cache(function(bins){
  var theta_max = utils.max_theta(bins);
  return Infer({model: function(){
    return categorical({
      vs: _.range(bins.length),//map(function(x) {return x.a;}, bins),
      ps: map(function(x) {
        if (x.b == "Infinity") {
          return (theta_max - x.a)/theta_max;
        } else {
          return eps + (x.b - x.a)/theta_max;
        }
      }, bins)
    });
  }});
});

var foreach = function(lst, fn) {
    var foreach_ = function(i) {
        if (i < lst.length) {
            fn(lst[i]);
            foreach_(i + 1);
        }
    };
    foreach_(0);
};


























var responseDictionary = { "agree-key": 1, "disagree-key": 0 };

var roundTo3 = function(x){
  return Math.round(x * 10000) / 10000
}

var nearestPriorBin = function(x, bns){
  return x > _.max(bns) ?
      _.max(bns) :
      x < _.min(bns) ?
      _.min(bns) :
      bns[Math.round(((x - _.min(bns))/(_.max(bns) - _.min(bns)))*(bns.length-1))]
}

var betaShape = function(p){
  return {a: p.g * p.d, b: (1-p.g) * p.d}
};


var avoidEnds = function(response){
    return response==0 ? 0.001 : response==1 ? 0.999 : response
}

var distProbs = function(dist, supp) {
  return map(function(s) {
    return Math.exp(dist.score(s))
  }, supp)
}

var KL = function(p, q, supp) {
  var P = distProbs(p, supp), Q = distProbs(q, supp);
  var diverge = function(xp,xq) {
    return xp == 0 ? 0 : (xp * Math.log(xp / xq) );
  };
  return sum(map2(diverge,P,Q));
};

var marginalize = function(myDist, label){
    Infer({method: "enumerate"}, function(){
        var x = sample(myDist);
        return x[label]
    });
};

var dataFrame = function(d, fieldsToNumerify){
    return map(
        function(lst){
            return _.fromPairs(map(function(l){
                return _.indexOf(fieldsToNumerify, l[0]) > -1 ?
                            [l[0], utils.wpParseFloat(l[1])] : l
            },
            _.zip(d[0],lst)
            ))
        },
        d.slice(1))
}

var displayObj = function(x){ display(JSON.stringify(x)) }




