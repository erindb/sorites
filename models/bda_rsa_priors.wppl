// ARGS.give_a_number data frame
// ARGS.concrete data frame
// ARGS.objects vector of objects

//////////////////////////////////////////
// helpers (move to package?)//////////
var foreach = function(lst, fn) {
    var foreach_ = function(i) {
        if (i < lst.length) {
            fn(lst[i]);
            foreach_(i + 1);
        }
    };
    foreach_(0);
};

var levels = function(df, label){
  return _.uniqBy(_.map(df, label));
};

// schematic bins: CHANGE TO actual prices...
var EPS = Number.EPSILON;
var roundTo3 = function(x){
  return Math.round(x * 1000) / 1000
}
var lowerBins = [
  0,0.01,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,
  0.5,0.55,0.6,0.65,0.7,0.75,0.8,0.85,0.9,0.95,0.99
];

var upperBins = [
  0.01,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,
  0.5,0.55,0.6,0.65,0.7,0.75,0.8,0.85,0.9,0.95,0.99, 1
];

var midBins = map2(function(b1,b2){
  return roundTo3((b2 - b1)/2 + b1)
}, lowerBins, upperBins)

var thetaBins = map2(function(b1, b2){
  return roundTo3((b2-b1)/2 + b1);
}, midBins.slice(0, midBins.length-1), midBins.slice(1))

var get_bins = cache(function(obj) {
  // bin in log space, even for uniform distribution
  var true_upper_bound = ARGS.upper_bounds[obj];
  var upper_bound = Math.log(true_upper_bound);
  var step = upper_bound/ARGS.nbins;
  var lowers = _.range(0, upper_bound, step);
  return map(function(x) {
    var lb = Math.exp(x);
    var ub = Math.exp(x+step);
    var mid = (ub + lb) / 2;
    return {
      LB: lb,
      mid: mid,
      UB: ub
    };
  }, lowers);
});

var convert_to_bin = cache(function(dollar_amount, bins) {
  return reduce(function(bin, best_so_far) {
    if (bin.LB <= dollar_amount && dollar_amount <= bin.UB) {
      return bin.mid;
    } else {
      return best_so_far;
    };
  }, false, bins);
});

var lognormal_prob_bin = function(gaussianParams, lb, ub) {
  return EPS +
      utils.lognormalCDF(ub, gaussianParams) -
      utils.lognormalCDF(lb, gaussianParams)
};

var DiscretizedLognormal = cache(function(gaussianParams, bins){
  var probabilities = map(function(bin){
    var ub = bin.UB;
    var lb = bin.LB;
    return lognormal_prob_bin(gaussianParams, lb, ub);
  }, bins);
  return Infer({model: function(){
    return categorical({
      vs: map(function(bin) {return bin.mid;}, bins),
      ps: probabilities
    })
  }})
});

var DiscretizedUniform = cache(function(bins) {
  return Infer({model: function(){
    return uniformDraw(map(function(x) {return x.LB;}, bins));
  }});
});

// TO FIX
// var OrdinalGaussian = function(params){
//   var thresholds = params.thresholds;
//   var mu = params.mu, sigma = params.sigma;
//   var bins = _.range(lowerBound, upperBound+1, binWidth);
//
//   var probs = mapIndexed(function(i, b){
//     i == 0 ? gaussianCDF({x:thresholds[i], mu: mu, sigma: sigma}) :
//     i == thresholds.length ? 1 - gaussianCDF({x:thresholds[i-1], mu: mu, sigma: sigma}) :
//     Math.max(Number.EPSILON, gaussianCDF({x:thresholds[i], mu: mu, sigma: sigma}) -
//                 gaussianCDF({x:thresholds[i-1], mu: mu, sigma: sigma}))
//   }, bins)
//
//   return Categorical({ps: probs, vs: bins});
// }
///

var objects = levels(ARGS.sorites, "object");

// TO FIX
// likert scale
// var likertParams = {LB: 0, UB: 9, binWidth: 1};
// var sampleLikertThreshold = function(b){
//  return b == likertParams.LB ? likertParams.LB + likertParams.binWidth/2 :
//         b == (likertParams.UB-1) ? likertParams.UB - likertParams.binWidth/2 :
//         gaussian(b + 0.5, 1/2)
// }
//

var meaning = function(utt, state, theta) {
  return utt == "expensive" ? state > theta :
         utt == "not expensive" ? state <= theta :
         utt == "cheap" ? state < theta :
         utt == "silence" ? true :
         true
}

var complex_add = function(key, val) {
  var basic_key = {
    type: "NA",
    label: "NA",
    dollar_amount: "NA",
    object: "NA",
    mid: "NA",
    UB: "NA",
    LB: "NA"
  };
  var new_key = _.extend(basic_key, key);
  var keystring = JSON.stringify(new_key);
  query.add(keystring, val);
};


var model = function() {
  var ALPHA1MAX = 20;
  var ALPHA2MAX = 5;
  var COSTMAX = 10;
  var MUMAX = 10;
  var SIGMAX = 3;
  var SIGBINMAX = .5;

  // var global_params = {
  //   alpha1: uniformDrift({a: 0, b: ALPHA1MAX, width: 1}),
  //   alpha2: uniformDrift({a: 0, b: ALPHA2MAX, width: 0.5}),
  //   cost: uniformDrift({a: 0, b: COSTMAX, width: 0.5}),
  //   sigbin: uniformDrift({a: 0, b: SIGBINMAX, width: 0.5})
  //   // TO FIX
  //   // likert_thresholds: map(sampleLikertThreshold,
  //   //  _.range(likertParams.LB, likertParams.UB, likertParams.binWidth)
  //   // )
  // };

  // var adjectivePriorProb = Math.exp(-global_params.cost);
  // var utterancePrior = Categorical({
  //   vs: ["expensive", "silence"],
  //   ps: [adjectivePriorProb, 1]
  // });

  foreach(objects, function(obj) {

    // subset each data type
    // var prior_bins = _.filter(ARGS.priorbins, {item: obj});
    var give_a_number = _.filter(ARGS.give_a_number, {object: obj});

    // var concrete = _.filter(ARGS.sorites, {object: obj, qtype: "concrete"});
    // var inductive = _.filter(ARGS.sorites, {object: obj, qtype: "inductive"});

    // priors on parameters of RSA state priors
    var item_params = {
      mu: uniformDrift({a: 0, b: MUMAX, width: 1}),
      sigma: uniformDrift({a: 0, b: SIGMAX, width: 0.5})
    };

    // factor by likelihood of sampled responses from give-a-number task
    mapData({data: give_a_number}, function(d) {
      // assume log of price is normally distributed
      var prob_of_sampled_price = Gaussian(item_params).score(
        Math.log(d.price)
      );
      factor(prob_of_sampled_price);
    });

    // factor based on binned histogram data
    // mapData({data: prior_bins}, function(d) {
    //   var ub = d.UB;
    //   var lb = d.LB;
    //   var human_response = d.normed_rating;
    //   var actual_prob = lognormal_prob_bin(item_params, lb, ub);
    //   factor(Gaussian(
    //     {mu: actual_prob, sigma: global_params.sigbin}
    //   ).score(human_response));
    // });


    // var posterior_predictive_itemPrior = Math.exp(gaussian(item_params));
    // complex_add(
    //   {type: "prior", object: obj, label: "price"},
    //   posterior_predictive_itemPrior
    // );

    complex_add(
      {type: "prior", object: obj, label: "mu"},
      item_params.mu
    );
    complex_add(
      {type: "prior", object: obj, label: "sigma"},
      item_params.sigma
    );

  //   var posterior_predictive_itemPrior = Math.exp(gaussian(item_params));
  //   complex_add(
  //     {type: "prior", object: obj, label: "price"},
  //     posterior_predictive_itemPrior
  //   );

  //   var bins = get_bins(obj);
  //   var statePrior = DiscretizedLognormal(item_params, bins);
  //   var thetaPrior = DiscretizedUniform(bins);

  //   // get posterior predtive for prior ratings for bins
  //   foreach(bins, function(bin) {
  //     var ub = bin.UB;
  //     var lb = bin.LB;
  //     var actual_prob = lognormal_prob_bin(item_params, lb, ub);
  //     var posterior_predictive_bin_rating = gaussian(
  //       {mu: actual_prob, sigma: global_params.sigbin}
  //     );
  //     complex_add(
  //       {
  //         type: "prior", 
  //         object: obj, 
  //         label: "bins", 
  //         mid: JSON.stringify(bin.mid), 
  //         UB: JSON.stringify(ub), 
  //         LB: JSON.stringify(lb)
  //       },
  //       posterior_predictive_bin_rating
  //     );
  //   });

  //  /// RSA model
  //  var listener0 = cache(function(utterance, theta) {
  //    Infer({model: function(){
  //      var state = sample(statePrior)
  //      var m = meaning(utterance, state, theta)
  //      condition(m)
  //      return state
  //   }})}, 10000)

  //  var speaker1 = cache(function(state, theta) {
  //    Infer({model: function(){
  //      var utterance = sample(utterancePrior);
  //      var L0 = listener0(utterance, theta);
  //      factor(global_params.alpha1 * L0.score(state))
  //      return utterance
  //    }})}, 10000)

  //  var listener1 = cache(function(utterance) {
  //    Infer({model: function(){
  //      var state = sample(statePrior);
  //      var theta = sample(thetaPrior);
  //      var S1 = speaker1(state, theta)
  //      observe(S1, utterance)
  //      return state
  //    }})}, 10000)

  //  var speaker2 = function(speakerBeliefs){
  //    Infer({model: function(){
  //      var utterance = sample(utterancePrior);
  //      var L1 = listener1(utterance)
  //      factor(global_params.alpha2 * L1.score(speakerBeliefs))
  //      return utterance
  //   }})}

  //   var dollar_amounts = levels(concrete, "dollar_amount")

  //   // foreach(dollar_amounts, function(dollar_amount){
  //   //   var concrete_byDollar = _.filter(concrete, {dollar_amount: dollar_amount});
  //   //   var inductive_byDollar = _.filter(inductive, {dollar_amount: dollar_amount});

  //   //   var discretized_dollar_amount = convert_to_bin(dollar_amount, bins);

  //   //   var concretePrediction = speaker2(discretized_dollar_amount);

  //   //   mapData({data: concrete_byDollar}, function(d){
  //   //     // for now, assume if > 5, then "YES", other NO
  //   //     var binarizedResponse = (d.response > 5) ? "expensive" : "silence";
  //   //     observe(concretePrediction, binarizedResponse)
  //   //   })

  //   //   var concrete_prob = Math.exp(concretePrediction.score("expensive"));
  //   //   complex_add(
  //   //     {type: "concrete", object: obj, dollar_amount: JSON.stringify(dollar_amount)},
  //   //     concrete_prob
  //   //   );

  //   // })

  });

  // complex_add(
  //   {type: "param", label: "alpha1"},
  //   global_params.alpha1
  // );
  // complex_add(
  //   {type: "param", label: "alpha2"},
  //   global_params.alpha2
  // );
  // complex_add(
  //   {type: "param", label: "cost"},
  //   global_params.cost
  // );
  // complex_add(
  //   {type: "param", label: "sigbin"},
  //   global_params.sigbin
  // );

  return query;
};


"finished";
