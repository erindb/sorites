// ARGS.give_a_number data frame
// ARGS.concrete data frame
// ARGS.objects vector of objects

//////////////////////////////////////////
// helpers (move to package?)//////////
var foreach = function(lst, fn) {
  var foreach_ = function(i) {
    if (i < lst.length) {
      fn(lst[i]);
      foreach_(i + 1);
    }
  };
  foreach_(0);
};

var levels = function(df, label){
  return _.uniqBy(_.map(df, label));
};

var EPS = Number.EPSILON;

var objects = levels(ARGS.sorites, "object");

// Truth value function for possible utterances.
var meaning = function(utt, state, theta) {
  return (utt == "expensive" ? state > theta :
          (utt == "not expensive" ? state <= theta :
           (utt == "cheap" ? state < theta :
            (utt == "silence" ? true : true))));
};

// Construct a single row in the output dataframe.
var add_output_datapoint = function(key, val) {
  var basic_key = {
    type: "NA",
    label: "NA",
    dollar_amount: "NA",
    object: "NA",
    mid: "NA",
    UB: "NA",
    LB: "NA"
  };
  var new_key = _.extend(basic_key, key);
  var keystring = JSON.stringify(new_key);
  query.add(keystring, _.clone(val));
};

// same # digits as webppl/src/math/numeric.ad.js
var LOG_2PI = 1.8378770664093453

// Erin, if this doesn't make sense, see "mistakes_i_made.Rmd"
// log of lognormal density
var lognormal_score = function(x, params) {
  var mu = params.mu;
  var sigma = params.sigma;
  return ((-Math.log(x)) +
          (-Math.log(sigma)) +
          (-0.5*LOG_2PI) +
          (-( Math.pow((Math.log(x) - mu), 2) /
              (2 * Math.pow(sigma, 2)) )));
};

var give_a_number_model = function() {
  var MUMAX = 10;
  var SIGMAX = 3;

  foreach(objects, function(obj) {

    // subset each data type
    // var prior_bins = _.filter(ARGS.priorbins, {item: obj});
    var give_a_number = _.filter(ARGS.give_a_number, {object: obj});

    // var concrete = _.filter(ARGS.sorites, {object: obj, qtype: "concrete"});
    // var inductive = _.filter(ARGS.sorites, {object: obj, qtype: "inductive"});

    // priors on parameters of RSA state priors
    var item_params = {
      mu: uniformDrift({a: 0, b: MUMAX, width: 1}),
      sigma: uniformDrift({a: 0, b: SIGMAX, width: 0.5})
    };

    // factor by likelihood of sampled responses from give-a-number task
    mapData({data: give_a_number}, function(d) {
      // assume log of price is normally distributed
      // so use lognormal density function
      // (see "mistakes_i_made.html" if in the future this doesn't make sense)
      factor(lognormal_score(d.price, item_params));
    });

    add_output_datapoint(
      {type: "prior", object: obj, label: "mu"},
      item_params.mu
    );
    add_output_datapoint(
      {type: "prior", object: obj, label: "sigma"},
      item_params.sigma
    );

  });

  return query;
};

var DiscretizedLognormal = function(item_params, bins) {
  var probs = map(function(bin) {
    var p_a = Math.exp(lognormal_score(bin.a, item_params));
    var p_b = Math.exp(lognormal_score(bin.b, item_params));
    var p = (p_a + p_b) / 2;
    if (utils.isNaN(p)) {
      return 0;
    } else {
      return p;
    }
  }, bins);
  return Categorical({ps: probs, vs: bins});
};

var DiscretizedUniform = function(bins) {
  return Infer({method: "enumerate"}, function() {
    // bins are evenly spaced (is this necessary?)
    var bin = uniformDraw(bins);
    return bin;
  });
};










var get_score = function(erp, value) {
  if (_.includes(erp.support(), value)) {
    return erp.score(value);
  } else {
    return Math.log(EPS);
  }
};

var score_mass_above_theta = function(theta, item_params) {
  1 - lognormal_score(theta, item_params);
}

var concrete_premise_model = function() {

  var ALPHA1MAX = 20;
  var ALPHA2MAX = 5;
  var COSTMAX = 10;
  var MUMAX = 10;
  var SIGMAX = 3;
  var SIGBINMAX = 0.5;

  var global_params = {
    alpha1: uniformDrift({a: 0, b: ALPHA1MAX, width: 1}),
    alpha2: uniformDrift({a: 0, b: ALPHA2MAX, width: 0.5}),
    cost: uniformDrift({a: 0, b: COSTMAX, width: 0.5}),
    sigbin: uniformDrift({a: 0, b: SIGBINMAX, width: 0.5})
  };

  // utterance prior
  var adjectivePriorProb = Math.exp(-global_params.cost);
  var utterancePrior = Categorical({
    vs: ["expensive", "silence"],
    ps: [adjectivePriorProb, 1]
  });

  foreach(objects, function(obj) {

    // subset to get each data type
    var give_a_number = _.filter(ARGS.give_a_number, {object: obj});
    var concrete = _.filter(ARGS.sorites, {object: obj, qtype: "concrete"});
    // var inductive = _.filter(ARGS.sorites, {object: obj, qtype: "inductive"});

    // priors on parameters of RSA state priors
    var item_params = {
      mu: uniformDrift({a: 0, b: MUMAX, width: 1}),
      sigma: uniformDrift({a: 0, b: SIGMAX, width: 0.5})
    };

    // discretization
    var dollar_amounts = levels(concrete, "dollar_amount");
    var bins = utils.get_bins(dollar_amounts, ARGS.n_bins);
    var statePrior = DiscretizedLognormal(item_params, bins);
    var thetaPrior = DiscretizedUniform(bins);

    // factor by likelihood of sampled responses from give-a-number task
    mapData({data: give_a_number}, function(d) {
      // assume log of price is normally distributed
      // so use lognormal density function
      // (see "mistakes_i_made.html" if in the future this doesn't make sense)
      factor(lognormal_score(d.price, item_params));
    });

    var listener0 = mem(function(utterance, theta) {
      return Infer({method: "enumerate"}, function() {
        var price = sample(statePrior);
        factor(meaning(utterance, state));
        return price;
      });
    });

    var speaker1 = mem(function(dollar_amount, theta) {
      return Infer({method: "enumerate"}, function() {
        var utterance = sample(utterancePrior);
        var expensive_is_true = dollar_amount > theta;
        var L0 = listener0(utterance, theta);
        var informativity = ( _.includes(L0.support(), dollar_amount) ? L0.score(dollar_amount) : 0 );
        factor(informativity);
        return utterance;
      });
    });

    var listener1 = mem(function(utterance) {
      return Infer({method: "enumerate"}, function() {
        var price = sample(statePrior);
        var theta = sample(thetaPrior);
        var S1 = speaker1(price, theta);
        var likelihood = ( _.includes(S1.support(), price) ? S1.score(price) : 0 );
        factor(likelihood);
        return price;
      });
    });

    var speaker2 = mem(function(dollar_amount) {
      return Infer({method: "enumerate"}, function() {
        var utterance = sample(utterancePrior);
        var L1 = listener1(utterance);
        var binned_dollar_amount = utils.bin_value(dollar_amount, bins);
        // display(binned_dollar_amount);
        // display(L1.support());
        var informativity = ( _.includes(L1.support(), binned_dollar_amount) ? L1.score(binned_dollar_amount) : 0 );
        factor(global_params.alpha2 * informativity);
        return utterance; 
      })
    });

     // output for each condition in sorites experiment
    foreach(dollar_amounts, function(dollar_amount){
      var concrete_byDollar = _.filter(concrete, {dollar_amount: dollar_amount});

      // ERP from utterances to probabilities, given the price of an object,
      // marginalizing over theta
      var S2 = speaker2(dollar_amount);

      mapData({data: concrete_byDollar}, function(d){
        // for now, assume if > 5, then "YES", other NO
        var binarizedResponse = (d.response > 5) ? "expensive" : "silence";
        observe(S2, binarizedResponse);
      });

      // if "expensive isn't in the support, return probability 0"
      var concrete_prob =  ( (_.includes(S2.support(), "expensive")) ?
                             Math.exp(S2.score("expensive")) :
                             0 );
      add_output_datapoint(
        {type: "concrete", object: obj, dollar_amount: JSON.stringify(dollar_amount)},
        concrete_prob
      );
    });

    add_output_datapoint(
      {type: "prior", object: obj, label: "mu"},
      item_params.mu
    );
    add_output_datapoint(
      {type: "prior", object: obj, label: "sigma"},
      item_params.sigma
    );

  });

  add_output_datapoint(
    {type: "param", label: "alpha1"},
    global_params.alpha1
  );

  add_output_datapoint(
    {type: "param", label: "alpha2"},
    global_params.alpha2
  );

  add_output_datapoint(
    {type: "param", label: "cost"},
    global_params.cost
  );

  return query;
};

// var concrete_premise_model = function() {

//     // priors on parameters of RSA state priors
//     var item_params = {
//       mu: uniformDrift({a: 0, b: MUMAX, width: 1}),
//       sigma: uniformDrift({a: 0, b: SIGMAX, width: 0.5})
//     };

//     var dollar_amounts = levels(concrete, "dollar_amount");
//     var max_price = utils.max(dollar_amounts);
//     /// RSA model

//     var speaker1_score = function(utterance, state, theta) {
//          if (state > theta) {
//           if (utterance == "expensive") {
//             var prob_greater_than_theta = 1 - Math.exp(lognormal_score(theta, item_params));
//             var informativity = -global_params.alpha1 * (Math.log(prob_greater_than_theta));
//             var cost_of_expensive = global_params.cost;
//             return informativity - cost_of_expensive;
//           } else {
//             return 0; // cost of no utterance is 0
//           }
//          } else {
//            // if x \leq \theta, then the utterance *cannot* be "expensive"
//           if (utterance == "expensive") {
//             return -Infinity;
//           } else {
//             return 0;
//           }
//          }
//        };

//     // no continuous parameters, so caching makes sense.
//     // if it helps. does it help?
//     // yep, gets called for each condition in the experiment
//     var listener1 = function(utterance, item_params) {
//       Infer({method: "incrementalMH",
//              samples: ARGS.internal_iterations,
//              lag: 1,
//              burn: ARGS.internal_iterations/2,
//              // verbose: false,
//              // verboseLag: ARGS.internal_iterations / 10,
//              model: function(){
//         // log is normally distributed
//         var log_price = gaussian(item_params);
//         var price = Math.exp(log_price);
//         var state = price;
//         var theta = uniform({a: 0, b: max_price});
//         return {
//           factor: factor(speaker1_score(utterance, state, theta)),
//           state: state
//         };
//       }})};
//     var listener1_score = function(utterance, speaker_belief_dollar_amount, item_params) {
//       var raw_L1 = listener1(utterance, item_params);
//       var factors = map(function(x) {x.factor}, raw_L1.support());
//       if (utils.max(factors) == -Infinity) {
//         return -Infinity;
//       } else {
//         var L1 = Infer({method: "enumerate"}, function() {
//           var x = sample(raw_L1);
//           factor(x.factor);
//           return x.state;
//         })
//         return get_score(L1, speaker_belief_dollar_amount);
//       }
//     };
//     // listener distribution is cached, so we just try both utterances
//     var speaker2 = function(speaker_belief_dollar_amount){
//      Infer({
//       method: "enumerate",
//       model: function(){
//          var utterance = sample(utterancePrior);
//          // this should be cached, so we can evaluate different dollar amounts for the same parameters
//          factor(global_params.alpha2 * listener1_score(utterance, speaker_belief_dollar_amount, item_params));
//          return utterance;
//       }})};

//     foreach(dollar_amounts, function(dollar_amount){
//       var concrete_byDollar = _.filter(concrete, {dollar_amount: dollar_amount});

//       var concretePrediction = speaker2(dollar_amount);

//       mapData({data: concrete_byDollar}, function(d){
//         // for now, assume if > 5, then "YES", other NO
//         var binarizedResponse = (d.response > 5) ? "expensive" : "silence";
//         observe(concretePrediction, binarizedResponse);
//       });

//       var concrete_prob = Math.exp(concretePrediction.score("expensive"));
//       add_output_datapoint(
//         {type: "concrete", object: obj, dollar_amount: JSON.stringify(dollar_amount)},
//         concrete_prob
//       );

//     });

//     add_output_datapoint(
//       {type: "prior", object: obj, label: "mu"},
//       item_params.mu
//     );
//     add_output_datapoint(
//       {type: "prior", object: obj, label: "sigma"},
//       item_params.sigma
//     );

//   });

//   add_output_datapoint(
//     {type: "param", label: "alpha1"},
//     global_params.alpha1
//   );
//   add_output_datapoint(
//     {type: "param", label: "alpha2"},
//     global_params.alpha2
//   );
//   add_output_datapoint(
//     {type: "param", label: "cost"},
//     global_params.cost
//   );

//   return query;
// };

// var model = function() {
//   var ALPHA1MAX = 20;
//   var ALPHA2MAX = 5;
//   var COSTMAX = 10;
//   var MUMAX = 10;
//   var SIGMAX = 3;
//   var SIGBINMAX = 0.5;

//   // var global_params = {
//   //   alpha1: uniformDrift({a: 0, b: ALPHA1MAX, width: 1}),
//   //   alpha2: uniformDrift({a: 0, b: ALPHA2MAX, width: 0.5}),
//   //   cost: uniformDrift({a: 0, b: COSTMAX, width: 0.5}),
//   //   sigbin: uniformDrift({a: 0, b: SIGBINMAX, width: 0.5})
//   //   // TO FIX
//   //   // likert_thresholds: map(sampleLikertThreshold,
//   //   //  _.range(likertParams.LB, likertParams.UB, likertParams.binWidth)
//   //   // )
//   // };

//   // var adjectivePriorProb = Math.exp(-global_params.cost);
//   // var utterancePrior = Categorical({
//   //   vs: ["expensive", "silence"],
//   //   ps: [adjectivePriorProb, 1]
//   // });

//   foreach(objects, function(obj) {

//     // subset each data type
//     // var prior_bins = _.filter(ARGS.priorbins, {item: obj});
//     var give_a_number = _.filter(ARGS.give_a_number, {object: obj});

//     // var concrete = _.filter(ARGS.sorites, {object: obj, qtype: "concrete"});
//     // var inductive = _.filter(ARGS.sorites, {object: obj, qtype: "inductive"});

//     // priors on parameters of RSA state priors
//     var item_params = {
//       mu: uniformDrift({a: 0, b: MUMAX, width: 1}),
//       sigma: uniformDrift({a: 0, b: SIGMAX, width: 0.5})
//     };

//     // factor by likelihood of sampled responses from give-a-number task
//     mapData({data: give_a_number}, function(d) {
//       // assume log of price is normally distributed
//       var prob_of_sampled_price = Gaussian(item_params).score(
//         Math.log(d.price)
//       );
//       factor(prob_of_sampled_price);
//     });

//     // factor based on binned histogram data
//     // mapData({data: prior_bins}, function(d) {
//     //   var ub = d.UB;
//     //   var lb = d.LB;
//     //   var human_response = d.normed_rating;
//     //   var actual_prob = lognormal_prob_bin(item_params, lb, ub);
//     //   factor(Gaussian(
//     //     {mu: actual_prob, sigma: global_params.sigbin}
//     //   ).score(human_response));
//     // });


//     // var posterior_predictive_itemPrior = Math.exp(gaussian(item_params));
//     // add_output_datapoint(
//     //   {type: "prior", object: obj, label: "price"},
//     //   posterior_predictive_itemPrior
//     // );

//     add_output_datapoint(
//       {type: "prior", object: obj, label: "mu"},
//       item_params.mu
//     );
//     add_output_datapoint(
//       {type: "prior", object: obj, label: "sigma"},
//       item_params.sigma
//     );

//   //   var posterior_predictive_itemPrior = Math.exp(gaussian(item_params));
//   //   add_output_datapoint(
//   //     {type: "prior", object: obj, label: "price"},
//   //     posterior_predictive_itemPrior
//   //   );

//   //   var bins = get_bins(obj);
//   //   var statePrior = DiscretizedLognormal(item_params, bins);
//   //   var thetaPrior = DiscretizedUniform(bins);

//   //   // get posterior predtive for prior ratings for bins
//   //   foreach(bins, function(bin) {
//   //     var ub = bin.UB;
//   //     var lb = bin.LB;
//   //     var actual_prob = lognormal_prob_bin(item_params, lb, ub);
//   //     var posterior_predictive_bin_rating = gaussian(
//   //       {mu: actual_prob, sigma: global_params.sigbin}
//   //     );
//   //     add_output_datapoint(
//   //       {
//   //         type: "prior",
//   //         object: obj,
//   //         label: "bins",
//   //         mid: JSON.stringify(bin.mid),
//   //         UB: JSON.stringify(ub),
//   //         LB: JSON.stringify(lb)
//   //       },
//   //       posterior_predictive_bin_rating
//   //     );
//   //   });

//   //  /// RSA model
//   //  var listener0 = cache(function(utterance, theta) {
//   //    Infer({model: function(){
//   //      var state = sample(statePrior)
//   //      var m = meaning(utterance, state, theta)
//   //      condition(m)
//   //      return state
//   //   }})}, 10000)

//   //  var speaker1 = cache(function(state, theta) {
//   //    Infer({model: function(){
//   //      var utterance = sample(utterancePrior);
//   //      var L0 = listener0(utterance, theta);
//   //      factor(global_params.alpha1 * L0.score(state))
//   //      return utterance
//   //    }})}, 10000)

//   //  var listener1 = cache(function(utterance) {
//   //    Infer({model: function(){
//   //      var state = sample(statePrior);
//   //      var theta = sample(thetaPrior);
//   //      var S1 = speaker1(state, theta)
//   //      observe(S1, utterance)
//   //      return state
//   //    }})}, 10000)

//   //  var speaker2 = function(speakerBeliefs){
//   //    Infer({model: function(){
//   //      var utterance = sample(utterancePrior);
//   //      var L1 = listener1(utterance)
//   //      factor(global_params.alpha2 * L1.score(speakerBeliefs))
//   //      return utterance
//   //   }})}

//   //   var dollar_amounts = levels(concrete, "dollar_amount")

//   //   // foreach(dollar_amounts, function(dollar_amount){
//   //   //   var concrete_byDollar = _.filter(concrete, {dollar_amount: dollar_amount});
//   //   //   var inductive_byDollar = _.filter(inductive, {dollar_amount: dollar_amount});

//   //   //   var discretized_dollar_amount = convert_to_bin(dollar_amount, bins);

//   //   //   var concretePrediction = speaker2(discretized_dollar_amount);

//   //   //   mapData({data: concrete_byDollar}, function(d){
//   //   //     // for now, assume if > 5, then "YES", other NO
//   //   //     var binarizedResponse = (d.response > 5) ? "expensive" : "silence";
//   //   //     observe(concretePrediction, binarizedResponse)
//   //   //   })

//   //   //   var concrete_prob = Math.exp(concretePrediction.score("expensive"));
//   //   //   add_output_datapoint(
//   //   //     {type: "concrete", object: obj, dollar_amount: JSON.stringify(dollar_amount)},
//   //   //     concrete_prob
//   //   //   );

//   //   // })

//   });

//   // add_output_datapoint(
//   //   {type: "param", label: "alpha1"},
//   //   global_params.alpha1
//   // );
//   // add_output_datapoint(
//   //   {type: "param", label: "alpha2"},
//   //   global_params.alpha2
//   // );
//   // add_output_datapoint(
//   //   {type: "param", label: "cost"},
//   //   global_params.cost
//   // );
//   // add_output_datapoint(
//   //   {type: "param", label: "sigbin"},
//   //   global_params.sigbin
//   // );

//   return query;
// };


"finished";
